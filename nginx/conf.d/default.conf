lua_package_path '/etc/nginx/lua/?.lua;;';

# We run dnsmasq on the same machine to resolve the DNS queries
# otherwise /etc/hosts does not get resolved
resolver 127.0.0.1;

# Get all the debugging
error_log stderr notice;

# Add multiple processes to test the eventual prod usecase
#worker_processes auto;
# cache for JWT verification results
lua_shared_dict jwt_verification 10m;

init_worker_by_lua_block {
    local config = require("config")
    -- if file does not exist, we take the default values
    config.load("/etc/nginx/lua/config.json")
}

server {
    # reuseport will help scalability
    # https://stackoverflow.com/questions/57494287/nginx-force-nginx-to-use-all-workers-for-load-balance
    # https://blog.cloudflare.com/the-sad-state-of-linux-socket-balancing/
    listen 8080 reuseport;
    server_name localhost;

    location / {
        return 200;
        access_log off;
    }

    location /webdav {
        alias /var/www/webdav;
        dav_methods PUT DELETE MKCOL MOVE;
        create_full_put_path on;
        autoindex on;
        # Disable code caching, which allows to edit and refresh w/o reloading
        # for testing
        lua_code_cache off;
        # tuning for large file uploads/downloads
        # based on https://stackoverflow.com/questions/11250798/best-file-system-for-serving-1gb-files-using-nginx-under-moderate-write-read-p
        sendfile off;
        output_buffers 1 128k;
        # aio on; directio 512;
        client_max_body_size 20G;
        content_by_lua_file /etc/nginx/lua/webdav_content.lua;
        access_by_lua_file /etc/nginx/lua/webdav_access.lua;
    }
}
